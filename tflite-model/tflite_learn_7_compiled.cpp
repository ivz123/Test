/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 30.10.2023 09:49:26

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#elif defined __ICCARM__
#define ALIGN(x) __attribute__((aligned(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1584;
#else
constexpr int kTensorArenaSize = 560;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};
struct NodeInfo_t { // subset of TfLiteNode used for initialization from constant memory
  struct TfLiteIntArray* inputs;
  struct TfLiteIntArray* outputs;
  void* builtin_data;
  used_operators_e used_op_index;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];
TfLiteNode tflNodes[4];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,39 } };
const ALIGN(16) float tensor_data1[10] = { 0.099933154881000519, 0.079672425985336304, 0.14244908094406128, 0.055026981979608536, 0.021788205951452255, 0.13549831509590149, -0.051638163626194, -0.026062851771712303, 0.048949923366308212, 0.031925301998853683, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { -0.00030386447906494141, -0.062385670840740204, 0.054659254848957062, 0.20050922036170959, 0.11659567803144455, 0.073964625597000122, -0.055101461708545685, 0.064880646765232086, -0.017142370343208313, -0.016065055504441261, 0.077886529266834259, 0.051901243627071381, -0.035961396992206573, 0.030167367309331894, 0.11737439036369324, -0.043191555887460709, -0.00041181466076523066, 0.021885838359594345, 0.014841301366686821, 0.1076480895280838, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(16) float tensor_data3[4] = { -0.10926081240177155, 0.058379512280225754, -0.1060318648815155, 0.091359235346317291, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) float tensor_data4[20*39] = { 
  0.11640434712171555, 0.1260581761598587, -0.26636934280395508, 0.31528091430664062, 0.26200920343399048, 0.21461924910545349, 0.12818723917007446, -0.16360205411911011, 0.13570165634155273, -0.22176162898540497, 0.039757430553436279, 0.14391019940376282, -0.24417309463024139, -0.066468700766563416, 0.1689414381980896, 0.28842577338218689, 0.12214890867471695, 0.36065006256103516, -0.086235269904136658, -0.10315446555614471, 0.30378493666648865, -0.050789464265108109, 0.28631293773651123, 0.08460458368062973, -0.25526407361030579, 0.2411060631275177, -0.0071878843009471893, -0.52137136459350586, 0.034111093729734421, -0.26860284805297852, 0.095737196505069733, 0.1635776162147522, 0.24798737466335297, -0.21956846117973328, -0.24370956420898438, 0.16585978865623474, -0.14964210987091064, 0.25977960228919983, 0.028011530637741089, 
  -0.2533729076385498, 0.09696902334690094, 0.11464935541152954, 0.017565758898854256, 0.032468870282173157, 0.089094221591949463, 0.062608741223812103, 0.17370873689651489, 0.2290528267621994, 0.43080711364746094, -0.051888424903154373, 0.22277361154556274, 0.13815402984619141, 0.10194852948188782, 0.39308536052703857, -0.02289130724966526, 0.19287332892417908, 0.14685951173305511, 0.30164554715156555, -0.16233699023723602, 0.0040340456180274487, 0.074210353195667267, 0.33898994326591492, 0.10880127549171448, 0.30820080637931824, 0.3299286961555481, 0.0076153827831149101, -0.044807359576225281, 0.076905660331249237, -0.28080457448959351, -0.081793047487735748, 0.30116477608680725, 0.34914156794548035, 0.37574481964111328, 0.4075767993927002, 0.068793162703514099, -0.033302821218967438, 0.16103693842887878, 0.29102945327758789, 
  0.20743373036384583, -0.27717280387878418, -0.11173138022422791, -0.2270197868347168, -0.010967808775603771, -0.11781418323516846, 0.28562110662460327, 0.30029755830764771, 0.33132541179656982, -0.0076090856455266476, -0.30756020545959473, 0.029354045167565346, -0.25803577899932861, 0.052065659314393997, -0.35586252808570862, 0.27877336740493774, 0.077760897576808929, 0.044171247631311417, 0.033138737082481384, 0.17754894495010376, 0.35497361421585083, -0.28944602608680725, 0.15745200216770172, -0.30571582913398743, -0.047636281698942184, -0.18251122534275055, 0.17893588542938232, 0.46008595824241638, -0.37588626146316528, -0.21480555832386017, -0.1750544011592865, 0.22080360352993011, 0.14422599971294403, -0.23705153167247772, -0.17527222633361816, -0.16636680066585541, -0.41320350766181946, -0.11091645807027817, 0.0045284954831004143, 
  -0.080475747585296631, -0.12908877432346344, 0.046813685446977615, 0.3515133261680603, -0.091408021748065948, 0.34681642055511475, 0.15164285898208618, 0.40773719549179077, 0.13132768869400024, -0.36762729287147522, -0.0058433474041521549, 0.0395924411714077, -0.052825026214122772, 0.23937839269638062, -0.064672745764255524, 0.068204149603843689, -0.13849900662899017, -0.33192852139472961, 0.24068120121955872, 0.35295507311820984, -0.078130781650543213, 0.1743023693561554, -0.26922520995140076, -0.32837352156639099, -0.058561418205499649, -0.11312615126371384, -0.19064831733703613, 0.50963497161865234, 0.0050037833862006664, 0.3790428638458252, -0.010667139664292336, 0.25874176621437073, 0.32830530405044556, -0.084931738674640656, -0.040400613099336624, -0.15794919431209564, -0.038143008947372437, -0.58771270513534546, -0.30756452679634094, 
  0.21541933715343475, 0.090999782085418701, 0.12003730237483978, -0.15667346119880676, -0.41980865597724915, -0.20237129926681519, 0.33331456780433655, -0.041390817612409592, -0.15207044780254364, 0.13217206299304962, -0.13624309003353119, 0.022101415321230888, -0.23033325374126434, 0.020580323413014412, -0.37507954239845276, 0.049341779202222824, 0.3212917149066925, 0.33346083760261536, 0.091613046824932098, -0.0038040634244680405, 0.029936376959085464, 0.33589377999305725, -0.012548258528113365, -0.015903305262327194, -0.066449664533138275, 0.045737944543361664, 0.35613077878952026, 0.15186448395252228, -0.4908888041973114, -0.090824097394943237, 0.33675724267959595, -0.11768893897533417, 0.32587060332298279, -0.17325721681118011, -0.075686037540435791, -0.11895745247602463, -0.080604836344718933, -0.27433478832244873, 0.079386718571186066, 
  -0.18177357316017151, 0.33691447973251343, 0.1833832859992981, -0.032156281173229218, -0.2772471010684967, -0.29320600628852844, 0.02844494953751564, 0.30520430207252502, -0.15747934579849243, -0.0029332232661545277, -0.32979726791381836, -0.16081394255161285, -0.3625236451625824, 0.3032190203666687, 0.084516584873199463, -0.14985936880111694, -0.20212878286838531, 0.16976229846477509, -0.069183796644210815, 0.031413592398166656, -0.22554352879524231, -0.24691116809844971, -0.016309570521116257, -0.14806485176086426, 0.23861171305179596, -0.063453182578086853, 0.20686063170433044, -0.32434326410293579, -0.14269782602787018, 0.38484135270118713, 0.013923068530857563, -0.026412224397063255, 0.2403070330619812, -0.18564946949481964, 0.078605905175209045, -0.28328931331634521, 0.22669099271297455, -0.18031099438667297, 0.14485017955303192, 
  0.1172168031334877, 0.17407135665416718, -0.31317660212516785, -0.16116748750209808, -0.0072082504630088806, -0.30356889963150024, -0.13879865407943726, 0.22972699999809265, -0.09391089528799057, 0.04392426460981369, 0.059300053864717484, 0.012635660357773304, 0.044238697737455368, 0.30688604712486267, 0.37010762095451355, -0.098386548459529877, -0.045451056212186813, 0.07231169193983078, 0.33860230445861816, 0.24860729277133942, -0.13752250373363495, 0.097674883902072906, -0.096530437469482422, 0.26986983418464661, -0.046957865357398987, 0.060552679002285004, 0.463672935962677, -0.64182907342910767, 0.49824658036231995, 0.069997631013393402, 0.27747675776481628, -0.25217142701148987, 0.071078427135944366, 0.01221659779548645, -0.13045866787433624, 0.25907179713249207, -0.16933669149875641, 0.21543866395950317, -0.10777003318071365, 
  0.35049155354499817, -0.48726660013198853, 0.15098834037780762, 0.35940641164779663, 0.41627883911132812, 0.17493797838687897, 0.15021917223930359, 0.18652692437171936, -0.024026047438383102, 0.40585198998451233, -0.047058731317520142, 0.32099631428718567, -0.087570108473300934, 0.12759745121002197, -0.13272437453269958, -0.14895704388618469, -0.11813387274742126, -0.3276766836643219, -0.18405546247959137, 0.35329034924507141, 0.30332410335540771, -0.17730528116226196, -0.20411962270736694, -0.074919097125530243, -0.15472021698951721, 0.23589418828487396, -0.076659716665744781, 0.15839901566505432, -0.24589942395687103, -0.0079413037747144699, 0.057576142251491547, 0.33619046211242676, 0.10173921287059784, -0.25099596381187439, -0.12471719086170197, -0.32704758644104004, -0.16281974315643311, 0.029338488355278969, 0.033620208501815796, 
  0.13224196434020996, 0.36719027161598206, 0.13757659494876862, -0.069474413990974426, -0.26870295405387878, 0.1588510125875473, -0.069208435714244843, -0.22834700345993042, -0.083537884056568146, -0.14263513684272766, -0.057319898158311844, 0.095886610448360443, 0.098526142537593842, -0.12898887693881989, -0.0060572871007025242, -0.21790046989917755, 0.18448746204376221, -0.036248303949832916, 0.2992275059223175, 0.026455763727426529, 0.25129511952400208, 0.17062565684318542, 0.24089169502258301, 0.076257318258285522, 0.15071459114551544, 0.15535721182823181, 0.20838651061058044, -0.0018720331136137247, 0.20527884364128113, -0.28223192691802979, 0.19333449006080627, -0.32303223013877869, -0.07697024941444397, -0.034633662551641464, -0.29163870215415955, -0.13305479288101196, -0.30811828374862671, 0.21024353802204132, -0.2328970730304718, 
  -0.26854181289672852, 0.064173266291618347, -0.19963152706623077, -0.038897275924682617, -0.18401508033275604, 0.17278851568698883, -0.29726144671440125, -0.013256804086267948, -0.17571868002414703, -0.3150542676448822, -0.26674556732177734, -0.21573904156684875, -0.31957167387008667, -0.11800584942102432, -0.13259349763393402, 0.32848256826400757, -0.076315589249134064, 0.12294605374336243, 0.19963277876377106, -0.21243442595005035, -0.076044142246246338, 0.18810881674289703, 0.045697197318077087, 0.27873292565345764, 0.30054795742034912, 0.19747428596019745, -0.01344773918390274, 0.1213492825627327, 0.0089025078341364861, 0.11319752037525177, -0.17354577779769897, -0.11087211966514587, -0.24372918903827667, -0.019005531445145607, 0.2114378809928894, 0.084294609725475311, 0.20120243728160858, 0.22766223549842834, -0.062710143625736237, 
  0.51504719257354736, -0.046266727149486542, 0.30157777667045593, -0.19673329591751099, -0.16117951273918152, 0.0019999158103018999, 0.27060815691947937, 0.13277052342891693, 0.048582252115011215, 0.20075249671936035, -0.1734040379524231, 0.13689139485359192, 0.12528851628303528, -0.11165380477905273, 0.43838909268379211, 0.095956116914749146, -0.019176330417394638, -0.22334195673465729, 0.17720121145248413, 0.19788438081741333, -0.15895788371562958, 0.23987075686454773, -0.23695521056652069, 0.29849681258201599, 0.29381281137466431, -0.0085528930649161339, 0.010041972622275352, -0.24907101690769196, 0.35725733637809753, 0.29909896850585938, -0.23290704190731049, -0.1558203250169754, -0.15794400870800018, 0.0037763586733490229, 0.36965095996856689, 0.34283626079559326, -0.04425559937953949, -0.18528167903423309, -0.20759296417236328, 
  0.020833985880017281, 0.032457001507282257, 0.33125293254852295, -0.045419853180646896, -0.25060248374938965, -0.21959479153156281, 0.36907333135604858, -0.071625970304012299, 0.28587204217910767, 0.0045854654163122177, 0.29686370491981506, 0.25643289089202881, 0.13950535655021667, 0.33673843741416931, -0.018842145800590515, 0.26178166270256042, -0.086873933672904968, -0.13170036673545837, 0.33157193660736084, 0.070261232554912567, -0.0068777473643422127, -0.0066646975465118885, 0.34833565354347229, 0.056986968964338303, 0.12143036723136902, 0.17613324522972107, 0.25839507579803467, 0.10619445890188217, 0.32920950651168823, 0.16955062747001648, 0.012909394688904285, -0.0098695475608110428, 0.080994084477424622, -0.07182728499174118, 0.13483968377113342, -0.014665920287370682, -0.1601274311542511, 0.14260318875312805, 0.10717888176441193, 
  -0.19146470725536346, -0.25293675065040588, -0.049719620496034622, -0.13725687563419342, 0.18385025858879089, -0.30560478568077087, -0.2192913293838501, -0.33058616518974304, -0.2734682559967041, 0.13285361230373383, -0.084157370030879974, -0.30067938566207886, 0.073948927223682404, 0.1254618912935257, -0.16636359691619873, 0.17378363013267517, 0.0047686472535133362, -0.11576274037361145, 0.23049449920654297, -0.12224864214658737, 0.1161070391535759, 0.15504941344261169, -0.2136491984128952, 0.18476979434490204, 0.14739985764026642, -0.11445697396993637, -0.024801695719361305, -0.13429208099842072, 0.2908720076084137, -0.12663134932518005, -0.17677608132362366, 0.042777400463819504, -0.3334101140499115, 0.25369691848754883, 0.17120987176895142, 0.17669147253036499, 0.2400670200586319, -0.22076980769634247, -0.27043032646179199, 
  0.2521044909954071, -0.33220639824867249, -0.39711087942123413, 0.075670510530471802, 0.45623749494552612, 0.33188441395759583, -0.26522055268287659, 0.28729343414306641, -0.036914847791194916, 0.07960587739944458, 0.060643050819635391, 0.097879625856876373, 0.29472813010215759, 0.16541041433811188, -0.050515811890363693, -0.42274004220962524, -0.25131881237030029, 0.065695561468601227, -0.24564626812934875, -0.12209424376487732, -0.27653807401657104, -0.27458688616752625, -0.041040953248739243, -0.12204781174659729, -0.14346237480640411, -0.32792457938194275, -0.11117736250162125, 0.25151142477989197, -0.044710341840982437, 0.072328865528106689, 0.14639918506145477, -0.29749488830566406, -0.23625794053077698, -0.31700199842453003, -0.050585173070430756, 0.051549084484577179, 0.12696151435375214, -0.042631980031728745, 0.25147125124931335, 
  0.30471813678741455, -0.27988278865814209, -0.0047601005062460899, 0.098532788455486298, -0.17981751263141632, -0.13907246291637421, -0.080400280654430389, 0.14623293280601501, 0.16870354115962982, 0.10167992860078812, 0.29933366179466248, -0.31808534264564514, -0.27680319547653198, 0.45723530650138855, -0.37576544284820557, -0.11659148335456848, -0.1520383208990097, 0.14095360040664673, 0.26109492778778076, -0.18009793758392334, 0.32905814051628113, 0.35725066065788269, -0.1125575453042984, 0.26878023147583008, -0.26160827279090881, -0.15017314255237579, 0.091554388403892517, -0.23011526465415955, 0.10340516269207001, 0.061303667724132538, 0.46508795022964478, -0.10186592489480972, -0.094744719564914703, 0.24601492285728455, -0.014072057791054249, -0.16926613450050354, -0.22310429811477661, 0.10008619725704193, 0.27257490158081055, 
  -0.049051746726036072, 0.31831541657447815, -0.27902418375015259, -0.3364301323890686, -0.24753595888614655, 0.024824436753988266, -0.10236168652772903, -0.01458983588963747, 0.036350280046463013, 0.018196774646639824, -0.10509630292654037, 0.044947102665901184, -0.23289722204208374, 0.09996747225522995, 0.0946531742811203, 0.19010384380817413, 0.013199559412896633, 0.12279720604419708, 0.049577537924051285, 0.12641909718513489, -0.35207241773605347, 0.19704155623912811, -0.33020064234733582, 0.068216249346733093, 0.00044119410449638963, -0.068365201354026794, -0.19047577679157257, -0.071102291345596313, -0.016613073647022247, -0.22161287069320679, 0.034273643046617508, -0.17203430831432343, -0.18012440204620361, 0.098979368805885315, -0.096317686140537262, -0.01392724271863699, -0.081997968256473541, -0.38222599029541016, 0.0081050405278801918, 
  0.05365120992064476, -0.23457689583301544, -0.14070059359073639, 0.025091433897614479, 0.40009903907775879, -0.10391532629728317, -0.14467546343803406, -0.27123084664344788, 0.074579127132892609, -0.3047012984752655, -0.31225574016571045, -0.1326901763677597, 0.04788343608379364, 0.12315438687801361, -0.10900024324655533, 0.16760958731174469, -0.24950949847698212, -0.1420445591211319, 0.095347821712493896, -0.14441570639610291, -0.31885924935340881, -0.23577708005905151, 0.068540990352630615, -0.18741533160209656, 0.081623964011669159, -0.15740032494068146, -0.071963474154472351, 0.14738848805427551, -0.15111982822418213, 0.21588911116123199, 0.10646078735589981, -0.042150557041168213, 0.20083773136138916, -0.23415926098823547, -0.14205276966094971, -0.21580956876277924, 0.039875149726867676, -0.3226650059223175, -0.19427050650119781, 
  -0.086671680212020874, 0.17501191794872284, 0.34858474135398865, 0.23030519485473633, 0.21744254231452942, -0.099261999130249023, -0.10408271849155426, 0.27175569534301758, 0.095224589109420776, -0.097956828773021698, -0.14876136183738708, 0.26479250192642212, -0.16063238680362701, 0.24734649062156677, -0.21811157464981079, -0.08192501962184906, -0.20821140706539154, 0.068384967744350433, 0.31411203742027283, -0.14768877625465393, 0.20604316890239716, -0.1014983206987381, -0.18676657974720001, 0.34343808889389038, -0.13748329877853394, -0.21609309315681458, -0.1453835517168045, 0.088073842227458954, -0.056715887039899826, -0.15769533812999725, -0.0077514578588306904, -0.22118973731994629, 0.018560666590929031, 0.096959926187992096, 0.034153450280427933, 0.33629652857780457, 0.29609453678131104, -0.16312706470489502, 0.21404272317886353, 
  -0.28807681798934937, -0.10987268388271332, 0.18976655602455139, -0.29586315155029297, 0.15682634711265564, 0.0086869038641452789, -0.22347034513950348, -0.04626261442899704, -0.025634348392486572, -0.12867417931556702, -0.30936026573181152, -0.13793317973613739, -0.28735411167144775, -0.24651339650154114, -0.21067799627780914, -0.12107573449611664, 0.037444796413183212, -0.1624026745557785, -0.19210329651832581, 0.10408330708742142, -0.17387071251869202, 0.24594755470752716, -0.18923084437847137, 0.23233924806118011, -0.15394841134548187, -0.29287675023078918, -0.035487927496433258, -0.1357906311750412, -0.23112531006336212, -0.20514063537120819, 0.15426300466060638, -0.15604479610919952, -0.2193131148815155, -0.30254575610160828, 0.29476693272590637, 0.23229342699050903, 0.069561779499053955, -0.23128025233745575, -0.26193630695343018, 
  0.15844422578811646, 0.29471373558044434, -0.2743518054485321, 0.024822698906064034, 0.21089072525501251, -0.0071294363588094711, 0.089305460453033447, -0.10072556138038635, 0.17481383681297302, 0.12161835283041, -0.37071552872657776, 0.1359521895647049, 0.150517538189888, 0.035265114158391953, 0.15788884460926056, -0.31464970111846924, 0.12990313768386841, -0.16255693137645721, -0.13115164637565613, 0.090356804430484772, -0.3285229504108429, -0.55602437257766724, -0.095251165330410004, -0.50016254186630249, -0.25620460510253906, -0.2360030859708786, -0.14099796116352081, 0.0033565314952284098, 0.21289649605751038, 0.31358897686004639, -0.26497593522071838, 0.104400634765625, 0.24904765188694, -0.37508898973464966, -0.096223145723342896, -0.15214963257312775, -0.52100712060928345, -0.18845461308956146, -0.18288533389568329, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,39 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.23461754620075226, -0.04216461256146431, -0.17758415639400482, 0.14036892354488373, 0.44673287868499756, 0.069752782583236694, 0.56480675935745239, -0.28329390287399292, 0.035327360033988953, -0.22275722026824951, 0.066121682524681091, 0.28050264716148376, 0.21832403540611267, 0.39768815040588379, 0.39067152142524719, -0.34774470329284668, -0.031745541840791702, 0.13409341871738434, -0.29452699422836304, -0.2455877810716629, 
  -0.3454577624797821, -0.70794826745986938, 0.37092053890228271, 0.47688481211662292, 0.33378535509109497, -0.090406209230422974, -0.32253226637840271, -0.23591119050979614, -0.21232491731643677, 0.075618930160999298, -0.020086560398340225, -0.12414608895778656, 0.2251463383436203, -0.15252889692783356, 0.28156140446662903, 0.33413514494895935, -0.045273572206497192, 0.18361401557922363, 0.23593714833259583, -0.12157954275608063, 
  -0.098841816186904907, -0.53803771734237671, 0.20743867754936218, 0.5808793306350708, 0.025224700570106506, -0.13273993134498596, -0.17591890692710876, 0.23030176758766174, -0.02869870513677597, 0.098286367952823639, 0.22764475643634796, 0.30727389454841614, -0.071929790079593658, -0.23973877727985382, 0.019406629726290703, -0.21727786958217621, 0.52922093868255615, -0.35880365967750549, -0.38720884919166565, -0.20327195525169373, 
  0.3084244430065155, 0.15313164889812469, 0.47571492195129395, 0.19223929941654205, -0.33508741855621338, 0.21931342780590057, -0.23461291193962097, -0.020266661420464516, -0.090077444911003113, 0.25580760836601257, 0.51369166374206543, 0.30535984039306641, -0.29528471827507019, -0.35648578405380249, -0.072445161640644073, -0.18784400820732117, -0.12562517821788788, -0.30011612176895142, 0.36153513193130493, 0.34208720922470093, 
  -0.12703210115432739, 0.24743849039077759, -0.31386935710906982, -0.0049202693626284599, -0.31559357047080994, 0.28829172253608704, -0.1260111927986145, 0.2324758917093277, -0.30491131544113159, 0.28764805197715759, 0.41909608244895935, 0.34730076789855957, -0.040191717445850372, 0.22905373573303223, 0.071281097829341888, -0.14992167055606842, -0.14612174034118652, 0.35912430286407471, 0.31074345111846924, 0.82426160573959351, 
  -0.017655486240983009, 0.40050694346427917, -0.081915028393268585, 0.36370217800140381, -0.27728679776191711, -0.79390931129455566, 0.093720197677612305, 0.47194498777389526, -0.41158917546272278, -0.093658685684204102, 0.61003768444061279, 0.34661760926246643, -0.12358736246824265, 0.65587919950485229, 0.031124508008360863, -0.19032727181911469, 0.11769968271255493, 0.2445150762796402, -0.71775293350219727, 0.49396723508834839, 
  0.57316082715988159, 0.31583002209663391, -0.30015486478805542, -0.34254437685012817, 0.24772663414478302, 0.31661200523376465, 0.1702599823474884, -0.1621706634759903, -0.17941126227378845, 0.077764496207237244, 0.35078701376914978, 0.20431144535541534, -0.23065471649169922, -0.061988469213247299, 0.034682527184486389, 0.045186862349510193, 0.2646452784538269, -0.079873718321323395, -0.0285338144749403, 0.42522880434989929, 
  -0.0040105483494699001, 0.37545636296272278, 0.10304056853055954, 0.14326515793800354, 0.0098004313185811043, 0.39422968029975891, 0.39500540494918823, -0.49286296963691711, 0.40317350625991821, -0.073824070394039154, -0.26308012008666992, 0.38636612892150879, 0.27507421374320984, -0.079469211399555206, -0.32482334971427917, 0.23692989349365234, 0.36547800898551941, 0.047905009239912033, 0.093345783650875092, 0.37458333373069763, 
  0.062151610851287842, -0.079599767923355103, 0.25757044553756714, 0.28121644258499146, 0.4239121675491333, 0.2048114687204361, -0.57790458202362061, 0.013194589875638485, -0.037353161722421646, -0.00035265879705548286, 0.26012396812438965, 0.024318164214491844, -0.061284009367227554, -0.43239489197731018, -0.095815993845462799, 0.32908070087432861, -0.14501611888408661, 0.28745892643928528, 0.10480853915214539, -0.077771604061126709, 
  0.028093919157981873, -0.25652888417243958, -0.077435150742530823, -0.028421398252248764, 0.49239614605903625, 0.55311614274978638, -0.074947714805603027, -0.0048394319601356983, 0.28085669875144958, -0.3478829562664032, -0.37765717506408691, 0.17204530537128448, -0.32298097014427185, -0.40159246325492859, 0.26464936137199402, -0.10824096202850342, -0.13575324416160583, 0.37323096394538879, 0.0075303604826331139, 0.0053390925750136375, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[4*10] = { 
  0.13926589488983154, 0.80214327573776245, 0.61928468942642212, -0.40614902973175049, -0.15312208235263824, -0.72945547103881836, -0.89160186052322388, -0.24615497887134552, 0.89678311347961426, 0.33800977468490601, 
  0.53923124074935913, -0.49682772159576416, -0.86387038230895996, -0.73568129539489746, -0.56088876724243164, -0.75881320238113403, 0.18948782980442047, 0.17613166570663452, -0.47558411955833435, 0.23597545921802521, 
  -0.58164942264556885, 0.43438029289245605, -0.60864120721817017, -0.55243015289306641, 0.48251444101333618, -0.70605933666229248, 0.61072289943695068, 0.37611156702041626, 0.23422834277153015, -0.44510814547538757, 
  0.052148167043924332, -0.28436076641082764, 0.16603164374828339, 0.39736554026603699, 0.25756701827049255, -0.061225328594446182, 0.41428491473197937, -0.2203078418970108, -0.55458658933639526, -0.87128132581710815, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 4,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,4 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,4 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension0, 156, },
  { kTfLiteMmapRo, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 40, },
  { kTfLiteMmapRo, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 80, },
  { kTfLiteMmapRo, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 16, },
  { kTfLiteMmapRo, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 3120, },
  { kTfLiteMmapRo, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 800, },
  { kTfLiteMmapRo, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 160, },
  { kTfLiteArenaRw, tensor_arena + 160, (TfLiteIntArray*)&tensor_dimension7, 80, },
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension8, 40, },
  { kTfLiteArenaRw, tensor_arena + 48, (TfLiteIntArray*)&tensor_dimension9, 16, },
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension10, 16, },
};const NodeInfo_t nodeData[] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, const_cast<void*>(static_cast<const void*>(&opdata0)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, const_cast<void*>(static_cast<const void*>(&opdata1)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, const_cast<void*>(static_cast<const void*>(&opdata2)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, const_cast<void*>(static_cast<const void*>(&opdata3)), OP_SOFTMAX, },
};

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  };
  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }
  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }

  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }
  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }
  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }
};

} // namespace

TfLiteStatus tflite_learn_7_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  ctx.impl_ = static_cast<void*>(&micro_context_);
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t i = 0; i < 4; ++i) {
    tflNodes[i].inputs = nodeData[i].inputs;
    tflNodes[i].outputs = nodeData[i].outputs;
    tflNodes[i].builtin_data = nodeData[i].builtin_data;
tflNodes[i].custom_initial_data = nullptr;
      tflNodes[i].custom_initial_data_size = 0;
if (registrations[nodeData[i].used_op_index].init) {
      tflNodes[i].user_data = registrations[nodeData[i].used_op_index].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for (size_t i = 0; i < 4; ++i) {
    if (registrations[nodeData[i].used_op_index].prepare) {
      ResetTensors();

      TfLiteStatus status = registrations[nodeData[i].used_op_index].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteStatus tflite_learn_7_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(inTensorIndices[index], tensor);
  return kTfLiteOk;
}

static const int outTensorIndices[] = {
  10, 
};
TfLiteStatus tflite_learn_7_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(outTensorIndices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[nodeData[i].used_op_index].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
